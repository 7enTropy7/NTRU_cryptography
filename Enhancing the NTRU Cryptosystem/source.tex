\documentclass[a4paper,12pt]{article}
\usepackage[utf8x]{inputenc}
\usepackage[top=0.5in,left=0.5in,right=0.5in,bottom=0.5in]{geometry}
\usepackage{xcolor}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage[english]{babel}
\usepackage{caption}
\usepackage{graphicx}
\graphicspath{{}}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}

\newtheorem{theorem}{Theorem}

\title{Enhancing the NTRU cryptosystem}

\author{
    \begin{tabular}[t]{c@{\extracolsep{1em}}c} 
    Awnon K. Bhowmik  & Unnikrishnan R. Menon\\
    \begin{small}Department of Mathematics and Computer Science\end{small} & \begin{small}Department of Electrical and Electronics\end{small} \\ 
    \begin{small}CUNY York College\end{small} & \begin{small}Vellore Institute of Technology\end{small} \\
    \begin{small}awnon.bhowmik@yorkmail.cuny.edu\end{small} & \begin{small}unnikrishnanr.menon2017@vitstudent.ac.in\end{small}
    \end{tabular}
}


\date{}

%\notag
\begin{document}
\maketitle
\begin{abstract}
    \begin{flushleft}
    NTRU is an open-source public key cryptosystem that uses lattice-based cryptography to encrypt and decrypt data. It consists of two algorithms, NTRUEncrypt, which is used for encryption, and NTRUSign which is used for digital signatures. Unlike other popular public-key cryptosystems, it is resistant to attacks using Shor's Algorithm and its performance has been shown to be significantly greater. This paper talks about how Koblitz encoding from Elliptic Curve Cryptography (ECC) can be used to convert each character in a dataset to a point on a elliptic curve. A Pythagoras Theorem analogy is used to turn the point to a single number, which is converted to a sequence of coefficients in $\mathbb{Z}$. A polynomial is then generated for each of these characters. Then the polynomial is reduced, and we show that choosing appropriate parameters for the cryptosystem can make it highly secure and that the decryption algorithm turns out taking exponential time. Since each character is represented by its own polynomial, it increases obscurity thereby increasing the time for decryption and thus the security level. We also implement a form of data compression and test whether data compression $\to$ encryption $\to$ decryption $\to$ data expansion results in original data with no or minimal loss.
    \end{flushleft}
\end{abstract}

\section{Why Lattice Cryptography}
\begin{flushleft}
\textbf{The real reason}$^{\cite{security_2017}}$
\begin{itemize}
    \item In 1994, Shor's Algorithm break RSA and ECC with quantum computers
    \item 2015, NSA announcement: prepare for the quantum apocalypse
    \item 2017, NIST call for competition/standardization
    \item 2030, predicted general purpose quantum computers
\end{itemize}

\textbf{Further usefulness}$^{\cite{security_2017}}$
\begin{itemize}
    \item Good understanding of underlying hard problem
    \item Fast, parallelable, hardware friendly
    \item Numerous applications: FHE, ABE, MMap, Obfuscation...
\end{itemize}

\textbf{Data vaulting attack}$^{\cite{security_2017}}$
\begin{itemize}
    \item A.k.a. harvest-then-decrypt attack
    \item Data needs to be secret for, lets say, 30 years
    \item Quantum computer arrives in, lets say, 15 years
    \item Perhaps the most practical attack in cryptography
\end{itemize}

\newpage
\textbf{Encrypt Schemes}$^{\cite{security_2017}}$
\begin{itemize}
    \item NTRUEncrypt - standardized by IEEE and ASC X9
\end{itemize}

\textbf{Signature Schemes}$^{\cite{security_2017}}$
\begin{itemize}
    \item BLISS (NTRU)
    \item pqNTRUSign (NTRU)
\end{itemize}

This paper focuses on the NTRUEncrypt and pqNTRUSign algorithm also known as NTRUSign algorithm.
\end{flushleft}

\section{Koblitz Encoding Algorithm for ECC}
\begin{flushleft}
	The encoding algorithm for ECC is as follows...\\
	\begin{itemize}
		\item Given a message $M$, convert each character $m_k$ into a number $a_k$ using Unicode, where $b=2^{16}$ and $0<a_k<2^{16}$
		\item Convert the message $M$ into an integer using $$m=\sum_{k=1}^n a_kb^{k-1}$$. In practice we choose an $n$ to be less than or equal to $160$ such that $m$ satisfies $m\le 2^{16\cdot 160}<p$.
		\item Fix a number $d$ such that $d\le \dfrac{p}{m}$. In practice we choose the prime $p$ large enough so that we can allow $d=100$.
		\item For integers $j=0,1,2,\cdots d-1$  we do the following loop
		\begin{itemize}
			\item Compute the $x$ coordinate of a point on the elliptic curve as $x_j=(dm+j)\mod p$ where $m=\bigg\lfloor{\dfrac{x_j}{d}}\bigg\rfloor$
			\item Compute $s_j=(x_j^3+Ax+B)\mod p$
			\item If $\left(s_j\right)^{\frac{p+1}{2}}\equiv s_j\mod p$, then define $y$ coordinate of a point on the elliptic curve as $y_j=\left(s_j\right)^{\frac{p+1}{4}}\mod p$. Return the point $(x_j,y_j)$.
		\end{itemize}
	\end{itemize}
	
	Thus we are able to encode our message $M$, as an element of the abelian group $G=E\left(\mathbb{F}_p\right)$ $^{[9]}$
\end{flushleft}

\section{NTRUEncrypt}
NTRU operations are based on objects in a truncated polynomial ring $R=\mathbb{Z}[X]/(X^N-1)$ with convolution multiplication and all polynomials in the ring have integer coefficients and degree at most $N-1$:
\begin{equation}
    \textbf{c}(X)=c_0+c_1X+c_2X^2+\cdots+c_{N-1}X^{N-1}
\end{equation}

\section{Equivalence class modulo 3}
Any number divided by 3 can result in remainders $\left\{0,1,2\right\}$. So any number divided by 3 is one of $3r,3r+1,3r+2$. This is useful in constructing the trinary basis $\left\{-1,0,1\right\}^{\text{dim}}$. The elements in the basis forms the coefficients of the polynomial $(1)$.

\newpage
\begin{theorem}
Let $R\subseteq S\times S$ be an equivalence class on a set $S$. Then the set of $\mathcal{R}$-classes constitutes the whole of $S$
\end{theorem}

\begin{proof}
    \notag
    \begin{align}
        \forall x\in S:x\in[x]_{\mathcal{R}}&\qquad\text{Definition of equivalence class}\\
        \lnot\left(\exists x\in S:x\notin [x]_{\mathcal{R}}\right)&\qquad\text{Assertion of universality}\\
        \lnot\left(\exists x\in S: x\notin\bigcup[x]_{\mathcal{R}}\right)&\qquad\text{Definition of set union}\\
        \forall x\in S:x\in\bigcup S/\mathcal{R}&\qquad\text{Assertion of universality}\\
        S\subseteq\bigcup S/\mathcal{R}&\qquad\text{Definition of subset}
    \end{align}
    
    Also:
    \begin{align}
        \forall X\in S/\mathcal{R}:X\subseteq S&\qquad\text{Definition of equivalence class}\\
        \bigcup S/\mathcal{R}\subseteq S&\qquad\text{Union is smallest superset: general result}
    \end{align}
    By definition of set equality
    $$\bigcup S/\mathcal{R}=S$$
    and so the set of all $\mathcal{R}$-classes constitutes the whole of $S^{\cite{proofwiki}}$.
\end{proof}

\begin{flushleft}
    This theorem tells us that in our case, we are using $\mod 3$ to generate coefficients from the set $\left\{-1,0,1\right\}$ which is basically the numbers of the form $3r-1,3r,3r+1$. It means that the union of all these equivalence classes spans the entire set of integers before modulo reduction.
\end{flushleft}

\section{Algorithm Flow Diagram}
\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!30]
\tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=3cm, minimum height=1cm, text width=3cm, text centered, draw=black, fill=blue!30]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text width=4cm, text centered, draw=black, fill=orange!30]
\tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]

\begin{tikzpicture}[node distance=2cm]
\node (start) [startstop] {Start};
\node (in1) [io, below of=start] {Input \textbf{String}};
\node (in2) [io, below of=in1] {Expand into \textbf{char} list};
\node (in3) [process, below of=in2, yshift=-0.5cm] {Pass through \textit{\textbf{Koblitz Encoder}}};
\node (in4) [io, below of=in3, yshift=-0.5cm] {$(x,y)$ point on elliptic curve $y^2=x^3+ax+b$};
\node (in5) [process, below of=in4,yshift=-0.5cm] {$t=x^2+y^2$};
\node (in6) [process, below of=in5,yshift=-0.5cm]{\scriptsize $n\mod 3\equiv\begin{cases}0\\1\\2\end{cases}\equiv\begin{cases}0\\1\\-1\end{cases}$};
\node (in7) [process, below of=in6,yshift=-0.5cm]{Repeat for all \textbf{chars} in $t_i$. Each $t_i$ is a list};
\node (in8) [process, right of=in7,xshift=3cm]{$n=\max(len(t_i))$};
\node (in9) [decision, right of=in6, xshift=3cm, yshift=0.5cm]{$\text{len}(t_i)<n$};
\node (in10) [process, right of=in9, xshift=3cm]{Apply padding};
\node (in11) [process, above of=in9,yshift=1.25cm]{Convert each $t_i$ to distinct polynomial};
\node (in12) [process, above of=in11]{Run \textbf{keypair generator}};
\node (in13) [io, above of=in12,xshift=0.2cm]{\textbf{Public Key}};
\node (in14) [process, above of=in13]{\tiny\textbf{NRTUEncrypt(polynomial)}};
\node (in15) [io, right of=in12,xshift=5cm]{\textbf{Private Key}};
\node (in16) [process, below of=in15]{\tiny\textbf{NRTUDecrypt(polynomial)}};
\node (in17) [process, below of=in10,yshift=-0.5cm]{\scriptsize $n\mod 3\equiv\begin{cases}0\\1\\-1\end{cases}\equiv\begin{cases}0\\1\\2\end{cases}$};
\node (in18) [io, below of=in17,yshift=-0.5cm]{return $(x,y)$};
\node (in19) [process, below of=in18]{Pass through \textit{\textbf{Koblitz Decoder}}};
\node (in20) [io, below of=in19]{list of \textbf{chars}};
\node (in21) [process, below of=in20]{join};
\node (in22) [io, left of=in21,xshift=-3.5cm]{Original \textbf{String}};
\node (stop) [startstop,left of=in22,xshift=-4cm]{Stop};

\draw[arrow](start)--(in1);
\draw[arrow](in1)--(in2);
\draw[arrow](in2)--(in3);
\draw[arrow](in3)--(in4);
\draw[arrow](in4)--(in5);
\draw[arrow](in5)--(in6);
\draw[arrow](in6)--(in7);
\draw[arrow](in7)--(in8);
\draw[arrow](in8)--(in9);
\draw[arrow](in9)--node[anchor=north]{yes}(in10);
\draw[arrow](in9)--node[anchor=east]{no}(in11);
\draw[arrow,dashed](in10)--(in11);
\draw[arrow](in10)--(in17);
\draw[arrow](in11)--(in12);
\draw[arrow](in12)--(in13);
\draw[arrow](in13)--(in14);
\draw[arrow](in12)--(in15);
\draw[arrow](in15)--(in16);
\draw[arrow](in16)--(in10);
\draw[arrow](in17)--(in18);
\draw[arrow](in18)--(in19);
\draw[arrow](in19)--(in20);
\draw[arrow](in20)--(in21);
\draw[arrow](in21)--(in22);
\draw[arrow](in22)--(stop);
\end{tikzpicture}


\section{An attempt on loss less encoding}
Messages encrypted by the Koblitz method results in a long polynomial. It is safe to assume that the length of this polynomial increases exponentially with the length of message. Hence, a modification to the aforementioned algorithm in Fig 1. was attempted by converting the polynomials into a gray scale map to obtain some sort of data compression. Following sample results were obtained.

\begin{center}
		\includegraphics[scale=0.6]{"Attempt 1".jpg}\captionof*{"Attempt 1".png}{\textbf{Attempt 1}}
		\includegraphics[scale=0.6]{"Attempt 2".jpg}\captionof*{"Attempt 2".png}{\textbf{Attempt 2}}
\end{center}

\begin{flushleft}
The first attempt involved PNG image format and produced results that were correct up to 2 decimal places only. This means that this format produced a large percentage error. Another thing to notice is that this involved only 8 bit precision unsigned integers. However, using TIFF image format with 64 bit precision unsigned integers resulted in a much better match between the encrypted and the decrypted matrix. Following is a sample gray scale map that was generated.
\end{flushleft}

\begin{center}
	\includegraphics[scale=0.75]{"grayscale map".jpg}\captionof*{"grayscale map".jpg}{Fig 2. \textbf{Gray scale map of data compression}}
\end{center}

\begin{flushleft}
\textbf{Remark:} It is to be noted that every character in our input string is treated differently, i.e. if we write the message "banana", then each of the characters have a different random polynomial. The polynomials for all 3 a's and both n's are distinct. This is what makes this cryptosystem more secure.
\end{flushleft}

\section{Finite fields in NTRU}
\begin{flushleft}
Field theory is an essential topic that forms the mathematical foundation of many cryptosystems. The NTRU cryptosystem is no different. The operations involved in our procedure are$^{\cite{latticehacks}}$

\begin{itemize}
	\item $p,q$ primes, where $p<q$
	\item addition - $f(x)+g(x)$
	\item multiplication - $f(x)\cdot g(x)$
	\item cyclic convolution - $f(x)\cdot g(x) \mod (x^n-1)$
	\item modular reduction - $\left(f(x_i)+\dfrac q2\right)\mod q - \dfrac q2 \quad \forall i\le n$. $n$ is the $\deg(f(x))$
\end{itemize}
\end{flushleft}

\begin{flushleft}
A \textbf{field} $F$, sometimes denoted $\left\{F,+,\times\right\}$ is a set of elements with two binary operation, called \textit{addition} and \textit{multiplication}, such as for all $a,b,c$ in $F$ the following axioms are obeyed.$^{\cite{stallings2017}}$
\end{flushleft}

\subsection{Properties of finite fields}
\begin{flushleft}
Consider a finite field $\left\{F,+,\times\right\}$. Let $x,y$ be any two arbitrary elements in the field. Then the following properties hold true.
\begin{enumerate}
	\item \textbf{Commutativity}\qquad\quad $\begin{cases}x+y&=y+x\\x\times y&=y\times x\end{cases}$
	\item \textbf{Associativity}\qquad\qquad\, $\begin{cases}x+(y+z)&=(x+y)+z\\x\times(y\times z)&=(x\times y)\times z\end{cases}$
	\item \textbf{Identity}\qquad\qquad\qquad\quad $\begin{cases}0\in F& x+0=0+x=x\\1\in F&1\times x=x\times 1=x\end{cases}$
	\item \textbf{Additive Inverse}\qquad\quad\, For any $x\in F$, there exists $-x\in F$ such that $x+(-x)=0$
	\item \textbf{Distributivity}\qquad\qquad\quad $(x+y)\times z=x\times z+y\times z$
	\item \textbf{Multiplicative Inverse}\quad For any $x\in F,x\neq 0, \exists x^{-1}\in F$ such that $x\times x^{-1}=1$
\end{enumerate}
\end{flushleft}

\begin{flushleft}
It can be shown that the order of a finite field (number of elements in the field) must be a power of a prime $p^n$, where n is a positive integer. The finite field of order $p^n$ is generally written $GF(p^n)$; $GF$ stands for Galois field, in honor of the mathematician who first studied finite fields. Two special cases are of interest for our purposes. For $n = 1$, we have the finite field $GF(p)$; this finite field has a different structure than that for finite fields with $n>1$ and is studied in this section. For finite fields of the form $GF(p^n), GF(2^n)$ fields are of particular cryptographic interest.${^{\cite{stallings2017}}}$
\end{flushleft}

\section{Experiments by varying parameters}
\subsection{String length vs time to encrypt/decrypt}
\begin{flushleft}
A function was written on Jupyter Notebook to test out the relationship between string length $s$ (x-axis) and time of encryption/decryption $t_{\text{enc}}/t_{\text{dec}}$ (y-axis).
\begin{center}
	\includegraphics[scale=0.75]{"strlen vs time".png}\captionof*{"strlen vs time".png}{Fig 3. \textbf{string length vs time to encrypt}}
\end{center}

A best fit shape through these points is a straight line through the \textit{origin}. It can be safely assumed that for an arbitrary string length $s$, time to encrypt $t_{\text{enc}}$ and time to decrypt $t_{\text{dec}}$, we can write
\end{flushleft}

\begin{itemize}
	\centering
	\item $t_{\text{enc}}\propto s$
	\item $t_{\text{dec}}\propto s$
\end{itemize}

\begin{flushleft}
To test the authenticity of our encryption paradigm we fixed elliptic curve parameters $(a,b)=(-96,-48)$. We generated a custom string of length $74$ that contained numeric values, alphabets (upper and lower case), special characters, spaces etc and generated $100$ new strings by randomly shuffling the elements of this custom string. It was observed that for each of the $100$ test cases, we were able to successfully retrieve the original message after completing an encrypt-decrypt cycle
\end{flushleft}

\subsection{Valid elliptic parameters vs String length}
\begin{enumerate}
	\item We take a custom string of length $74$. This consists of all alphnumeric characters, special characters and space.
	\item We run a $O(n^2)$ complexity loop to check for $(a,b)$ in range $[-100,100]$.
	\item Due to lack of recommended processing power, we break out of the loop as soon as the first combination is found. The combination turned out to be $(a,b)=(-96,-48)$
	\item We shuffled the original string $100$ times to make $100$ different strings of length $74$.
	\item For each of the shuffled strings, we only consider the first 20 characters due to shortage of processing power. So basically we now have $100$ strings of length $20$ that comprises of any random character on the English keyboard.
	\item We run the encrypt-decrypt function on these strings. The job of the encrypt-decrypt function is to return true only if the decrypted message matches perfectly with the input plaintext.
\end{enumerate}

\begin{flushleft}
We observed that for each of the $100$ test cases, the encrypt-decrypt function returns true.
\end{flushleft}

\section{Conjecture}
\begin{enumerate}
	\item The elliptic curve parameter $(a,b)=(-96,-48)$ works irrespective of the string length of the message and the type of characters present in the string.
	\item $(a,b)=(-96,-48)$ is one of the many combinations of elliptic curve parameter that works. Proof of this is dependent on greater computational power.
\end{enumerate}

\section{Future Work}
\begin{flushleft}
We are planning to wrap up the entire program into a pip install package which would be available for general public use. NTRU algorithm has been around for a while but there is still no official implementation of this algorithm in libraries such as pycryptodome. We would love to see our version of NTRU becoming a part of this library. It will serve as a great security layer against post quantum cryptography. We would also like to incorporate this crypto system as a security layer for a web socket based client server chat app, built with Tkinter.
\end{flushleft}
\newpage
\bibliographystyle{ieeetran}
\bibliography{References}

\end{document}